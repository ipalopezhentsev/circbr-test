/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;

import org.junit.jupiter.api.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.github.resilience4j.bulkhead.Bulkhead;
import io.github.resilience4j.bulkhead.BulkheadConfig;
import io.github.resilience4j.ratelimiter.RateLimiter;
import io.github.resilience4j.ratelimiter.RateLimiterConfig;

import static org.junit.jupiter.api.Assertions.*;

import java.time.Duration;
import java.util.ArrayList;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;
import java.util.function.Function;
import java.util.function.Supplier;

class RateLimiterVsBulkheadTest {
    private static final Logger log = LoggerFactory.getLogger(RateLimiterVsBulkheadTest.class);

    @Test
    void rateLimiterJustSlowsDownAndDoesntFailInDefaultSetup() {
        // limits num of requests in some duration - slows them down but doesnt fail
        // (UNLESS it waits for more than 5 secs - default value of timeoutDuration)
        var rateLimitConfig = RateLimiterConfig.custom()
                .limitRefreshPeriod(Duration.ofSeconds(1L))
                .limitForPeriod(10)
                .build();
        var rateLimiter = RateLimiter.of("rl", rateLimitConfig);
        rateLimiter.getEventPublisher().onEvent(evt -> log.info(evt.toString()));

        Function<Supplier<CompletionStage<String>>, Supplier<CompletionStage<String>>> rateLimiterProtectionDecorator = origFunction -> RateLimiter
                .decorateCompletionStage(rateLimiter, origFunction);
        var numErrors = runParallelRqs(rateLimiterProtectionDecorator);
        assertEquals(numErrors, 0);
    }

    @Test
    void rateLimiterCanBeFailing() {
        // timeoutDuration is 5 secs by default, if we decrease it rate limiter will
        // start failing surplus requests
        var rateLimitConfig = RateLimiterConfig.custom()
                .limitRefreshPeriod(Duration.ofSeconds(1L))
                .limitForPeriod(10)
                .timeoutDuration(Duration.ofSeconds(0L))
                .build();
        var rateLimiter = RateLimiter.of("rl", rateLimitConfig);
        rateLimiter.getEventPublisher().onEvent(evt -> log.info(evt.toString()));

        Function<Supplier<CompletionStage<String>>, Supplier<CompletionStage<String>>> rateLimiterProtectionDecorator = origFunction -> RateLimiter
                .decorateCompletionStage(rateLimiter, origFunction);
        var numErrors = runParallelRqs(rateLimiterProtectionDecorator);
        assertTrue(numErrors > 0);
    }

    @Test
    void bulkheadActivelyFailsRqsInDefaultSetup() {
        // limits num of simultaneous(!) rqs - and doesn't slow them down but rejects -
        // but only on default settings (which have maxWaitDuration=0).
        var bulkheadConfig = BulkheadConfig.custom()
                .maxConcurrentCalls(10)
                .maxWaitDuration(Duration.ofMinutes(0))
                .build();
        var bulkhead = Bulkhead.of("bl", bulkheadConfig);
        bulkhead.getEventPublisher().onEvent(evt -> log.info(evt.toString()));

        Function<Supplier<CompletionStage<String>>, Supplier<CompletionStage<String>>> bulkheadProtectionDecorator = origFunction -> Bulkhead
                .decorateCompletionStage(bulkhead, origFunction);
        var numErrors = runParallelRqs(bulkheadProtectionDecorator);
        assertTrue(numErrors > 10);
    }

    @Test
    void bulkheadCanBeAskedToWaitForSomeTimeBeforeRejecting() {
        // limits num of simultaneous(!) rqs - and doesn't slow them down but rejects -
        // but only on default settings (which have maxWaitDuration=0).
        var bulkheadConfig = BulkheadConfig.custom()
                .maxConcurrentCalls(10)
                .maxWaitDuration(Duration.ofMinutes(1))
                .build();
        var bulkhead = Bulkhead.of("bl", bulkheadConfig);
        bulkhead.getEventPublisher().onEvent(evt -> log.info(evt.toString()));

        Function<Supplier<CompletionStage<String>>, Supplier<CompletionStage<String>>> bulkheadProtectionDecorator = origFunction -> Bulkhead
                .decorateCompletionStage(bulkhead, origFunction);
        var numErrors = runParallelRqs(bulkheadProtectionDecorator);
        assertEquals(numErrors, 0);
    }

    private int runParallelRqs(
            Function<Supplier<CompletionStage<String>>, Supplier<CompletionStage<String>>> protectionDecorator) {
        int numErrors = 0;
        var futs = new ArrayList<CompletableFuture<String>>();
        int numRqs = 100;
        for (int i = 0; i < numRqs; i++) {
            var localI = i;
            log.info("" + localI);
            try {
                Supplier<CompletionStage<String>> bareFunction = () -> {
                    return CompletableFuture.supplyAsync(() -> {
                        try {
                            Thread.sleep(1000);
                        } catch (InterruptedException e) {
                            throw new RuntimeException(e);
                        }
                        return "Result #" + localI;
                    });
                };
                Supplier<CompletionStage<String>> protectedFunction = protectionDecorator.apply(bareFunction);
                futs.add(protectedFunction.get().toCompletableFuture());
            } catch (Exception ex) {
                log.error("Fail on #" + localI, ex);
                numErrors++;
            }
        }
        assertEquals(numRqs, futs.size());
        assertEquals(0, numErrors);

        for (int i = 0; i < numRqs; i++) {
            var fut = futs.get(i);
            try {
                var res = fut.join();
            } catch (Exception ex) {
                numErrors++;
            }
        }
        return numErrors;
    }
}
