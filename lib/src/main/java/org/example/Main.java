/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;

import java.time.Duration;
import java.util.ArrayList;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;
import java.util.concurrent.Executors;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.function.Supplier;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.github.resilience4j.circuitbreaker.CircuitBreaker;
import io.github.resilience4j.circuitbreaker.CircuitBreakerConfig;
import io.github.resilience4j.circuitbreaker.CircuitBreakerConfig.SlidingWindowType;
import io.github.resilience4j.circuitbreaker.event.CircuitBreakerEvent;
import io.github.resilience4j.core.IntervalFunction;
import io.github.resilience4j.decorators.Decorators;
import io.github.resilience4j.retry.Retry;
import io.github.resilience4j.retry.RetryConfig;

public class Main {
    private static final Logger log = LoggerFactory.getLogger(Main.class);

    public static void main(String[] args) {

        CircuitBreakerConfig circuitBreakerConfig = CircuitBreakerConfig.custom()
                .failureRateThreshold(50)
                .waitDurationInOpenState(Duration.ofMillis(1000))
                .permittedNumberOfCallsInHalfOpenState(2)
                .slidingWindowSize(2)
                .slidingWindowType(SlidingWindowType.COUNT_BASED)
                .build();

        CircuitBreaker circuitBreaker = CircuitBreaker.of("cb", circuitBreakerConfig);
        var evtPub = circuitBreaker.getEventPublisher();
        evtPub.onEvent((CircuitBreakerEvent evt) -> {
            log.info(evt.toString());
        });
        // Let's make an executor service that has queue with limited capacity and which
        // throws exceptions when trying to submit a task in case its queue is already
        // full. We dont specify rejection handler, so default is used - AbortPolicy,
        // throwing RejectedExecutionException if there's no space in the queue
        var boundedExecSvc = new ThreadPoolExecutor(4, 4, 0, TimeUnit.SECONDS, new ArrayBlockingQueue<>(1));
        var unboundedExecSvc = Executors.newScheduledThreadPool(4);
        var futs = new ArrayList<CompletableFuture<String>>();
        int numRqs = 100;
        int numErrors = 0;

        IntervalFunction retryIntervalFn = IntervalFunction.ofExponentialRandomBackoff(1000, 2.0, 0.5);
        var retryConfig = RetryConfig.custom()
                .intervalFunction(retryIntervalFn)
                .maxAttempts(5)
                .build();
        var retry = Retry.of("rtr", retryConfig);
        retry.getEventPublisher().onEvent(evt -> log.info(evt.toString()));

        for (int i = 0; i < numRqs; i++) {
            final int localI = i;
            try {
                Supplier<CompletionStage<String>> resilientFunc = Decorators.<String>ofCompletionStage(() -> {
                    return CompletableFuture.<String>supplyAsync(() -> {
                        try {
                            Thread.sleep(1000);
                            return "Result " + localI;
                        } catch (InterruptedException e) {
                            log.error("", e);
                            throw new RuntimeException(e);
                        }
                    }, boundedExecSvc);
                })
                        .withCircuitBreaker(circuitBreaker)
                        .withRetry(retry, unboundedExecSvc)
                        //.withFallback(_ -> "Result (fallback) " + localI)
                        // .withRateLimiter(rateLimiter)
                        //.withBulkhead(bulkhead)
                        .decorate();

                var futResilientRes = resilientFunc.get().toCompletableFuture();

                futs.add(futResilientRes);
                log.info("Submitted future #{}", i);
            } catch (RejectedExecutionException ex) {
                numErrors++;
                log.error("Error submitting future #{}", i, ex);
            }
        }

        var numFallbacks = 0;
        for (var fut : futs) {
            try {
                var res = fut.join();
                if (res.contains("fallback")) {
                    numFallbacks++;
                }
                log.info(res);
            } catch (Exception ex) {
                numErrors++;
                log.error("Error obtaining future result", ex);
            }
        }
        log.info("Num requests: {}, num errors: {}, numFallbacks: {}", numRqs, numErrors, numFallbacks);
    }
}
